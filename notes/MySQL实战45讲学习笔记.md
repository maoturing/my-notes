# 1. 基础架构

MySQL 的基本架构示意图如下所示，大体可以分为 Server 层和存储引擎层两部分

![MySQL 的基本架构示意图](https://gitee.com/tracccer/picture-bed/raw/master/img/%E4%B8%8B%E8%BD%BD.png)

Server 层包括**连接器、查询缓存、分析器、优化器、执行器**等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

而**存储引擎层负责数据的存储和提取**。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。



## 1.1 连接器

连接器负责跟客户端建立连接、获取权限、维持和管理连接。

连接 MySQL，Windows 上需要进入MySQL 安装目录，然后执行

```cmd
cd bin
./mysql -uroot -p
```

如果是连接远程 MySQL，则输入

```cmd
mysql -h$ip -P$port -u$user -p
```

如果密码错误会提示访问非法 Access denied

```
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)
```



连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。

- 如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。
- 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。

这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。



使用`show processlist`查看当前 MySQL 的所有连接，其中的 Command 列显示为`Sleep`的这一行，就表示现在系统里面有一个空闲连接。

![image-20211224232628934](https://gitee.com/tracccer/picture-bed/raw/master/img/image-20211224232628934.png)



客户端如果太长时间没查询/更新等操作，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。即上图中 Time 列的数字达到 28800 后连接会被断开，当连接进行查询、更新等操作后，这个数字会被重置。

查看连接最长空闲时间参数 wait_timeout，这里的  28800 秒即 8 小时。

```sql
mysql> show global variables like 'wait_timeout';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| wait_timeout  | 28800 |
+---------------+-------+
1 row in set (0.00 sec)
```



数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。

> 如果设置连接为长连接/短连接?



建立连接的过程通常是比较复杂的，所以我建议你在**使用中要尽量减少建立连接的动作**，也就是尽量使用长连接。

如果全部使用长连接，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接很多，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 `mysql_reset_connection` 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。



## 1.2 查询缓存（不重要）

连接建立完成后，就可以执行 select 查询语句了，执行步骤就来到了**查询缓存**。

```sql
mysql> select * from T where ID=10；
```

MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。

**但是大多数情况下不建议使用查询缓存，为什么呢？因为查询缓存极其容易失效。**

查询缓存的失效非常频繁，只要有对一个表有更新，那么这个表上有关的查询缓存会全部被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。



MySQL 查询缓存默认是关闭的，下面的 OFF 代表关闭查询缓存。

```sql
mysql> show global variables like 'query_cache_type';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| query_cache_type | OFF   |
+------------------+-------+
1 row in set (0.00 sec)
```

如果将其修改为 DEMAND，那么可以使用`SQL_CACHE`在查询时显式指定使用查询缓存。可能在极少数耗时查询，并且表很少修改的情况下适用。

```sql
mysql> select SQL_CACHE * from T where ID=10;
```



MySQL 8.0 版本直接将查询缓存的整块功能删掉了。



## 1.3 分析器

```sql
mysql> select * from T where ID=10；
```

如果没有命中查询缓存，就要真正开始执行 SQL 了。MySQL 要知道你的目的，必须对 SQL 语句进行解析。

分析器会先做**词法分析**，分析 SQL 语句中 select 关键字，表示是一个查询语句，把字符串 T 识别为表名 T，把字符串 ID 识别为列 ID。

然后再做**语法分析**，分析输入的 SQL 是否满足 MySQL 语法。下面是 select 语句少打了开头的 s 的报错信息

```
ERROR 1064 (42000): You have an error in your SQL syntax; 
	check the manual that corresponds to your MySQL server version 
	for the right syntax to use near 'elect * from t where ID=1' at line 1
```

一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接`use near`的内容。





## 1.4 优化器

经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。



## 1.5 执行器

MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

开始执行前，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，则返回没有权限的错误

```sql
mysql> select * from T where ID=10;
 
ERROR 1142 (42000): 
	SELECT command denied to user 'b'@'localhost' for table 'T'
```

如果有权限，比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。



## 1.6 问题

> 问题：如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？

答案是分析器，分析器的作用之一就是将字符串 k 识别为列 k，分析器在解析 SQL 后会生成一棵树，并检查树是否合法，包括检查数据表和数据列是否存在, 别名是否有歧义，通过后再提交给优化器。



> 问题：MySQL的框架有几个组件, 各是什么作用？

连接器，查询缓存，分析器，优化器，执行器，存储引擎。

连接器：负责跟客户端建立连接、获取权限、维持和管理连接。
查询缓存：查询请求先访问缓存(key 是查询的语句，value 是查询的结果)。命中直接返回。不推荐使用缓存，更新会把缓存清除。
分析器：对 SQL 语句做解析，判断 SQL 是否正确。
优化器：决定使用哪个索引，多表关联（join）的时候，决定各个表的连接顺序。
执行器：执行语句，先判断用户有无查询权限，然后调用存储引擎接口进行查询。



> 问题：Server层和存储引擎层各是什么作用？

Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。



> 问题：对于表的操作权限验证在哪里进行，为什么？

在执行器阶段，比如触发器需要在执行过程中才能确定，优化器阶段前是无能为力的。



> 问题：执行器的执行查询语句的流程是什么样的？

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。



> 问题：一条查询 SQL 语句是如何执行的？

一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。





# 2. 日志系统



```sql
mysql> update T set c=c+1 where ID=2;
```

查询 SQL 的执行过程与上一章讲的类似，首先通过连接器连接数据库，然后把表 T 相关的缓存都情况，接下来分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。



与查询流程不一样的是，更新流程还涉及两个重要的日志模块：

- redo log（重做日志）
- bin log（归档日志）



## 2.1 redo log

如果有人要赊账或者还账的话，掌柜一般有两种做法：

1. 直接把账本翻出来，找到这个顾客的记录，把这次赊的账加上去或者扣除掉；
2. 先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。

在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。



在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。

而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 **WAL 技术**，WAL 的全称是 Write-Ahead Logging，它的关键点就是**先写日志，再写磁盘**，也就是先写粉板，等不忙的时候再写账本。

需要注意的是：“先写日志” 也是先写磁盘，只是写日志是顺序写盘，速度很快。

------

具体来说，**当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了**。

同时，**InnoDB 引擎会在空闲的时候，将这个操作记录更新到磁盘里面**，这就像打烊以后掌柜做的事。



如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。

InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。（有些类似 MapReduce 的操作，复习对比一下）

![16a7950217b3f0f4ed02db5db59562a7](https://gitee.com/tracccer/picture-bed/raw/master/img/16a7950217b3f0f4ed02db5db59562a7.png)

write pos 表示当前操作要写入 redo log 的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。

check point 表示记录写入磁盘并删除 redo log 的位置，也是往后推移并且循环的。

write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。

**有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe**。





## 2.2 bin log

粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog 归档日志。

redo log 与 bin log 有三点不同：

- redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
- redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。



执行器和 InnoDB 引擎在执行简单的 update 语句时的过程如下：

```sql
mysql> update T set c=c+1 where ID=2;
```

1. 执行器先通过引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这条记录所在的数据也本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的记录，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

![img](https://gitee.com/tracccer/picture-bed/raw/master/img/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

上面第三步和第五步，是 redo log 写入的两个步骤 prepare 和 commit，这就是**两段式提交**





## 2.3 两段式提交

> 怎样让数据库恢复到半个月内任意一秒的状态？

binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果系统每周定期做了整库备份，并且保存了最近半个月的所有 binlog，那么就可以将数据库恢复到半个月内任意一秒的状态。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

1. 找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
2. 从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。



前面就是数据的恢复过程，再结合 2.2 节提到的数据库异常重启，可以通过 redo log 恢复写入的记录，即 crash-safe 功能。



仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？

如果不采用两段式提交，那么写入 redo log 和 binlog 的顺序只有两种情况：

1. **先写 redo log 后写 binlog**。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启，然后我们可以通过 redo log 恢复数据，恢复后 c 的值为 1。

   但是由于 bin log 没写完 MySQL 就异常重启 crash 了，如果后面需要用 binlog 恢复临时库时，这次修改会丢失，恢复后 c 的值为 0，与原库不同。

2. **先写 binlog 后写 redo log**。如果在 binlog 写完之后，MySQL 进程异常重启crash，由于 redo log 还没写，恢复以后这个事务无效，所以这一行 c 的值为 0。但是后面如果使用 binlog 恢复临时库，这一行 c 的值为 1，与原库的值不同。



综上，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。





1. redo log的概念是什么? 为什么会存在.

2. 什么是WAL(write-ahead log)机制, 好处是什么.

3. redo log 为什么可以保证crash safe机制.

4. binlog 的概念是什么, 起到什么作用, 可以做crash safe吗?

5. binlog 和 redolog 的不同点有哪些?

6. 物理一致性和逻辑一直性各应该怎么理解?

7. 执行器和 innoDB 在执行 update 语句时候的流程是什么样的?

8. 如果数据库误操作, 如何执行数据恢复?

9. 什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?

10. 如果不是两阶段提交, 先写 redo log 和先写 bin log 两种情况各会遇到什么问题?

11. 如果两段式提交，未执行完写 binlog 后 MySQL 崩溃重启，与执行完写 binlog 后 MySQL 崩溃重启，两种有什么区别？

    答：未执行完写 binlog 后 MySQL 崩溃重启，重启后根据

