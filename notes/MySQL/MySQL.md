# 1. 索引

**索引的结构**

innodb 这种原生的数据文件就是索引文件的组织结构，就叫默认的主键索引为聚簇索引。也正是因为这个原因，innodb 表要求必须有主键，而 myiasm不要求必须有主键。在innodb 存储引擎下，如果对某个非主键的字段创建索引，那么最后那个叶子节点的值就是主键的值。

```
select * from table where name='tom'
```



先到 name 的索引里去找，找到 tom 所对应的叶子节点，叶子节点的data就是那一条数据的主键 id=15，然后再根据 id=15，到数据文件里面的聚簇索引（根据主键设置的索引）查找 id=15 来定位出来这一条数据的所有值。



这里也明白了一个道理，为什么 innodb 不要用 UUID 生成的超长字符做主键？因为这样做会导致所有的索引的 data 都是那个主键值，最终导致索引会变得过大，浪费磁盘空间。



聚簇索引：innodb将默认的主键索引叫聚簇索引。

[MySQL索引-B+树](http://www.liuzk.com/410.html)

**索引的使用规则**

最左前缀匹配原则

对一个商品表按照店铺、商品、创建时间三个维度来查询，一般不会建立 3 个索引，而是会创建一个联合索引：

```sql
create index(shop_id, product_name, gmt_create) 
```

最左前缀匹配原则

1. 全列匹配，你的查询sql中，where 条件就使用了这 3 个字段，那么一定可以用到这个联合索引

```sql
select * from product where shop_id=1 and product_name=1 and gmt_create='2018-1-1'
```

2. 最左前缀匹配，你的查询sql中，where 条件中最左边的一个或几个条件，与索引匹配，也是可以用这个联合索引的

```sql
select * from product where shop_id=1 and product_name=1
```

3. 最左前缀匹配，但是中间某个值没匹配。此时仍会使用这个联合索引，先查找出与`shop_id`匹配的100条数据，然后对结果全扫描一遍，使用剩下的条件 `gmt_create`进行过滤。只有最左匹配的字段能用到索引，而且还有一个额外的过滤工作，但是还能用到索引，所以性能也还可以。

```sql
select * from product where shop_id=1 and gmt_create='2018-1-1'
```



4. 最左前缀不匹配，不会使用索引。

```sql
select * from product where product_name=1
```

5. 范围列匹配，范围查询，比如 >, <, between 操作，只有使用范围查询的字段`shop_id`可以使用索引，对查询结果使用后面的字段`product_name`进行过滤

```sql
select * from product where shop_id>2 and product_name=1
```





**索引的缺点**

1. 尽量创建少的索引。过多索引会增加磁盘消耗，因为要占用磁盘文件，高并发时频繁插入和修改索引，会导致性能损耗。

2. 值不够分散的的字段不要创建索引。比如 status 字段只有两个值 0 和 1，创建索引对查询的速度帮助不大。如果对 id 建立索引，就可以利用二分查找，大大减少要扫描的数据量。



对于 MySQL尽量不要写 join，子查询，函数等操作，高并发场景下，计算放到内存中通过 java 代码来做。





# 2. 事务



ACID

1. Atomic 原子性：一堆SQL，要么一起成功，要么一起失败
2. Consistency 一致性：事务开启之前，数据必须是准确的，事务关闭之后，数据也必须是准确的
3. Isolation 隔离性：多个事务之间不能互相干扰，A事务正执行，B事务过来修改了一个数据，导致A事务出错
4. Durability 持久性：事务成功了，就必须永久对数据的修改时有效的，即必须在磁盘修改





> **事务隔离**

**事务隔离是解决事务内多次读不一致问题**，准确的说是为了解决读事务与写事务的并发问题，读与读事务没有问题，写与写事务之间都是有顺序的

1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据，即错误的数据
　　
2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。

3、幻读：事务 A 第一次读取得到 10 条数据，事务B插入了 1 条数据，事务A再次读发现数据变多了，就好像发生了幻觉一样，这就叫幻读。

小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表


| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| :--------------------------- | :--: | :--------: | :--: |
| 读未提交（read-uncommitted） |  是  |     是     |  是  |
| 读已提交（read-committed）   |  否  |     是     |  是  |
| 可重复读（repeatable-read）  |  否  |     否     |  是  |
| 串行（serlalizable）         |  否  |     否     |  是  |

**read-uncommitted**：读未提交，即能读取到没有commit的数据，所以这个级别的事务隔离无法解决脏读问题

**read-committed**：读已提交，即只能读取已经commit的数据，所以可以防止脏读，但由于别人仍可以修改并提交数据，所以无法解决不可重复读问题

**repeatable-read**：可重复读，在数据读出来之后加锁，直至事务结束，其他人才可以修改这些数据。明确数据读出来就是为了更新，所以要加一把锁，防止其他人修改，解决了不可重复读的问题，因为锁住的是读取出来的数据，别人可以新增数据，所以无法解决幻读的问题

**serlalizable**：串行，最高的事务隔离级别，串行执行事务，即不允许并发执行事务，只有一个事务执行完成后，才能执行下一个事务，这样就解决了幻读问题，缺点是串行执行事务效率很低

MySQL 默认事务级别是 可重复读（repeatable-read），但是 MySQL 解决了幻读问题。即在一个事务内，即使其他事务修改了数据或删除了数据并提交，MySQL 多次读取数据一定是一致的，这个技术成为**快照读**。

再次强调，事务隔离是解决事务内多次 **读** 不一致的问题。如果事务 A 修改了 id=1 的数据，未提交，然后事务 B 也修改 id=1 的数据，会发现事务B 中的 SQL 一直在等待，直至事务 A 进行了 commit，所以事务并发写排好了队，（应该是加了行锁），不会出现两个事务同时修改数据的情况。



### 1.2.7 事务传播详解与开启事务

- REQUIRED 需要事务，如果存在事务，则加入；如果不存在事务，则创建
- REQUIRES_NEW  创建新事务，如果存在事务，则挂起已存在的事务
- NESTED  创建新事务，如果存在事务，则嵌套

-----

- SUPPORTS  支持事务，如果存在事务，则加入；如果不存在，则不使用事务
- NOT_SUPPORTED  不支持事务，如果存在事务，则挂起；如果不存在，则不使用事务

-----

- MANDATORY  强制使用事务，如果不存在事务，则抛出异常
- NEVER   不使用事务，如果存在事务，则抛出异常

事务传播机制中，使用同一个事务就类似于一根绳子上的蚂蚱，一出错全部回滚；而 REQUIRES_NEW 创建新的子事务则相当于另一个绳子上的蚂蚱，出错了不会影响主事务。

**注意：** 

1. 如果子事务中的错误抛出来了，那也会影响主事务，如果 try-catch 住则不会影响主事务
2. REQUIRED 如果存在主事务，则加入，那么事务的配置属性如 timeout 等会继承主事务的，自己设置的不生效。
3. 数据库中并没有 REQUIRES_NEW，挂起主事务，创建子事务的操作。事务传播底层是 JDBC，REQUIRED 会把主事务的 connection 传递给子方法，REQUIRES_NEW 子方法会创建新的 connection 来执行 SQL，来达到创建新事务的目的
4. 事务传播不能在同一个类的方法中生效，事务传播一般都是 A.a() 中调用 B.b()，AOP 进行了代理，实际上变为了 Aproxy.a() 调用 Bproxy.b()，在方法执行前后就加入了切面事务代码。





# 参考文档

[MySQL实战45讲 - 极客时间](https://time.geekbang.org/column/intro/100020801)