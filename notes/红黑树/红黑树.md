<!-- TOC -->

- [1. 2-3 树](#1-2-3-树)
    - [1.1 2-3树查找元素](#11-2-3树查找元素)
    - [1.2 2-3树删除元素](#12-2-3树删除元素)
        - [删除最小元素](#删除最小元素)
        - [删除任意元素](#删除任意元素)
    - [1.3 2-3树与AVL](#13-2-3树与avl)
- [2. 红黑树RBTree](#2-红黑树rbtree)
    - [2.1 红黑树与2-3 树的等价性](#21-红黑树与2-3-树的等价性)
    - [2.2 红黑树的性质](#22-红黑树的性质)
- [待补充](#待补充)
- [线段树](#线段树)
- [字典树Trie](#字典树trie)
- [参考文档与推荐阅读](#参考文档与推荐阅读)

<!-- /TOC -->
# 1. 2-3 树

​	前面讲到了二叉搜索树 (BST) 和二叉平衡树 (AVL) ，二叉搜索树在最好的情况下搜索的时间复杂度为 O(logn) ，但如果插入节点时，插入元素序列本身就是有序的，那么BST树就退化成一个线性表了，搜索的时间复杂度为 O(n)。

如果想要减少比较次数，就需要降低树的高度。在插入和删除节点时，要保证插入节点后不能使叶子节点之间的深度之差大于 1，这样就能保证整棵树的深度最小，这就是AVL 树解决 BST 搜索性能降低的策略。但由于每次插入或删除节点后，都可能会破坏 AVL 的平衡，而要动态保证 AVL 的平衡需要很多操作，这些操作会影响整个数据结构的性能，除非是在树的结构变化特别少的情形下，否则 AVL 树平衡带来的搜索性能提升有可能还不足为了平衡树所带来的性能损耗。

具有2个孩子的节点称为**2节点**，具有3个孩子的节点称为**3节点**，这种有2节点和3节点的二分搜索树称为**2-3 树**，他有以下性质：

1. 满足二分搜索树的基本性质，
2. 节点可以存放一个或两个元素
3. 节点大于左子节点，小于右子节点
4. 两个元素的节点有三个子节点，分别在两个元素的左中右
5. **2 - 3树是一棵绝对平衡的树**，从根节点到任意一个叶子节点经过的节点数量是相同的
6. 节点的左子树或右子树也是 2-3 树？是吗

![2-3树](https://raw.githubusercontent.com/maoturing/PictureBed/master/pic/23树.png)

上图是一个2-3树，满足二分搜索树的基本性质，比如根节点42的左子树全部比根节点小；42的左孩子是一个3节点，具有两个元素 [17 33] ，并且左孩子都小于17，右孩子大于33，中孩子大于17且小于33；根节点的右孩子是一个二节点，只有一个元素 50，并且有两个孩子。

## 1.1 2-3树查找元素

2-3树的查找类似二分搜索树的查找，根据元素的大小来决定查找的方向。要判断一个元素是否存在，我们先将待查找元素和根节点比较，如果它和其中任意一个相等，那查找命中；否则根据比较的结果来选择查找的方向。

 ![查找元素](https://raw.githubusercontent.com/maoturing/PictureBed/master/pic/20200303191437.png)

 ## 插入元素

插入元素首先进行查找命中，若查找命中则不予插入此元素，如果需要支持重复的元素则将这个元素对象添加一个属性count。若查找未命中，则在叶子节点中插入这个元素。

 

空树的插入很简单，创建一个节点即可。如果不是空树，插入的情况分为4种：

1. 向2-节点中插入元素；

2. 向一颗只含有一个3-节点的树中插入元素；

3. 向一个父节点为2-节点的3-节点中插入元素；

4. 向一个父节点为3-节点的3-节点中插入元素。

 

**1. 向2-节点中插入元素**
 

如果未命中查找结束于2-节点，直接将2-节点替换为3-节点，并将待插入元素添加到其中。

 ![插入元素1](https://raw.githubusercontent.com/maoturing/PictureBed/master/pic/20200303191538.png)

 

**2. 向一棵只含有一个3-节点的树中插入元素**

 

如果命中查找结束于3-节点，先临时将其成为4-节点，把待插入元素添加到其中，然后将4-节点转化为3个2-节点，中间的节点成为左右节点的父节点。如果之前临时4-节点有父节点，就会变成**向一个父节点为2-节点的3-节点中插入元素**，中间节点与父节点为2-节点的合并。

![插入元素2](https://raw.githubusercontent.com/maoturing/PictureBed/master/pic/20200303191628.png)

 

**3. 向一个父节点为3-节点的3-节点中插入元素**

 

插入元素后一直向上分解临时的4-节点，直到遇到2-节点的父节点变成3-节点不再分解。如果达到树根节点还是4-节点，则进行分解根节点，此时树高+1（只有分解根节点才会增加树高），下面动画2-3树插入会出这个例子。
![插入元素3](https://raw.githubusercontent.com/maoturing/PictureBed/master/pic/20200303191741.png)

--------
上面4种向2-3树中插入元素的情况，动画如下图所示：
![2-3树插入元素动画](https://raw.githubusercontent.com/maoturing/PictureBed/master/pic/23树插入元素.gif)

## 1.2 2-3树删除元素

 

算法4红黑树删除最小键这一小结里没有特别详细地介绍，但给到了沿着左链接向下进行变换的三种情况：

1. 如果左子节点不是2-节点，完成；

2. 如果左子节点是2-节点，而兄弟节点不是2-节点，将兄弟节点的最小元素移到父节点，父节点的最小元素移到左子节点；

3. 如果左子节点是2-节点，而兄弟节点是2-节点，则左子结点、父节点中最小的元素和兄弟结点合并成4-结点。

 
![2-3树删除元素](https://raw.githubusercontent.com/maoturing/PictureBed/master/pic/20200303192041.png)






### 删除最小元素

我们注意到在叶子节点不是2-节点的时候，删除一个元素是很简单的，而且删除时不考虑自平衡处理。如果删除一个2-节点会留下一个空节点，破坏了2-3树的绝对平衡。所以，为了保证不会删除一个2-节点，可以设定最左边或者最右边进行向下变换节点。这里设置沿最左边的链接，进行向下变换的三种情况正是如上图中，左子节点的父节点除了根节点都会变换成3-节点或4-节点。

### 删除任意元素

删除任意元素需要进行命中查找。如果查找未命中则忽略之；如果查找命中则向二叉堆一样删除任意元素，将带删除元素右子树的最小元素替换到待删除元素上，然后对右子树进行删除最小元素。

## 1.3 2-3树与AVL

2-3 树作为一种平衡查找树，查询效率比普通的二叉排序树要稳定许多。但是2-3树需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。

**彩蛋：** 学习抽象的数据结构很有用的一个方法，使用小的数据集，动手画出插入、删除等操作的过程，相比直接去看代码有效高效的多。



# 2. 红黑树RBTree

**红黑树**源于Leo J. Guibas 和 Robert Sedgewick（算法4作者）于1978写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况[运行时间](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90)，并且在实践中高效：它可以在 O(logn) 时间内完成查找，插入和删除。



## 2.1 红黑树与2-3 树的等价性

红黑树本质上和 2-3 树是等价的，2-3 树中有两种节点，分别是2-节点和 3-节点。在数据结构中，绝大多数树结构，每个节点都只能存储一个元素，那么能不能将 2-3 树做一些转换，使得 2-3 树每个节点也只存储一个元素呢？

2-3 树节点存储一个元素的转换过程如下所示：

1. 2-节点 [a] 转换为一个黑节点 a
2. 3-节点 [b c] 也可以转换为两个**并列**相连的黑节点
   1. 因为 b<c ，所以 b 作为 c 的左孩子下移，使用**红色边**表示 b 和 c 存在并列关系，表示在2-3树中 b 与 c 保存在一个 3-节点中
   2. 在实际代码中，没有必要定义一个边的类，由于 节点 b 和红色边是一一对应关系，所以可以将节点 b 标记为红色，表示节点与其唯一的父节点是并列关系。

![节点转换过程](https://raw.githubusercontent.com/maoturing/PictureBed/master/pic/红黑节点.png)

我们把这种 2-3 树转换后，节点分为红黑节点的树称为红黑树。根据红黑树的转换过程，可以知道**红色节点都是左倾斜的**，这不是推导出来的，而是定义出来的。


![红黑树与2-3树](https://raw.githubusercontent.com/maoturing/PictureBed/master/pic/红黑树转换22.png)

上图是将一个 2-3 树转换为红黑树，为了与 2-3 数类比，我们可以将红色节点与父节点并列来看。可以看到，所有 3-节点左边的值都是红色节点，与 2-3 树类似，根节点到达所有节点经过的黑色节点数相等，节点大于左孩子，小于右孩子。

查看红黑树[示例代码](https://github.com/liuyubobobo/Play-with-Data-Structures/blob/master/13-Red-Black-Tree/03-The-Equivalence-of-RBTree-and-2-3-Tree/src/RBTree.java)

## 2.2 红黑树的性质

《算法导论》中介绍了红黑树的 5 条性质：

1. 每个节点是红色或黑色的

   ​	红色表示 2-3 树中的 3-节点中的左值

2. 根节点是黑色的 

   ​	2-3树无论根节点是2-还是3-节点，转换为红黑树根节点都是黑色

3. 每一个叶子节点即最后的空节点都是黑色的

4. 如果一个节点是红色的，那么他的子节点都是黑色的，父节点也是黑色的

   ​	无论红色节点的子节点是2-节点还是 3-节点，转换为红黑树节点都是黑色的

   ​	反之如果一个节点是黑色的，那么他的右孩子一定是黑色的

5. **从任意一个节点向下到其叶子节点，经过的黑色节点数是一样的**

   ​	2-3树是一个绝对平衡的树，根节点到任意叶子节点的经过的节点个数是一致的，而任意节点是高度固定的，故向下到叶子节点的距离是一致的

   ​	在红黑树中，红色节点是3-节点的左值，也就是经过的黑色节点数是一致的
   ​	

总而言之，红黑树是一个保持“黑平衡”的二叉树，在严格意义上，红黑树不是平衡二叉树，因为平衡二叉树左子树与右子树深度最大差为1，而红黑树极端情况最大高度是 2logn，最大差为logn。但是在时间复杂度，查找元素的时间复杂度为O(logn)，修改元素要先查找，时间复杂度也是O(logn)，插入删除一个元素也是O(logn)。



   经常插入或删除，红黑树更好，插入完后不经常变动只查找，AVL更好

   ​	



# 待补充
HashMap中的红黑树应用


# 线段树

# 字典树Trie



# 参考文档与推荐阅读

1. [玩转数据结构 - 慕课网](https://coding.imooc.com/class/207.html)
2. [图解2-3树 - 五分钟学算法](https://mp.weixin.qq.com/s/kZo58Lq7rxjqO5M3c-fPRA)
3. [图解红黑树 - 五分钟学算法](https://mp.weixin.qq.com/s/lm3WKiq2BvxRq8Ym03J-yw)